# -*- coding: utf-8 -*-
"""Chapter3_Neural Networks_&_Path_to_Generative_Models.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZuvitxKbZ13un9AdhEn6iLjVHzUlhxQ-

# Neural Network

**Neural networks** are computational models inspired by the human brain. They are used when traditional machine learning algorithms fall short because neural networks can automatically learn complex, nonlinear patterns from large, high-dimensional data that conventional methods often cannot handle.

#### Structure:

**Input Layer:** Receives the raw data.

**Hidden Layers:** One or more layers where neurons transform inputs through weighted connections and nonlinear activation functions.

**Output Layer:** Produces the final prediction or classification.

### Perceptron
It is the simplest type of artificial neural network â€” essentially a single-layer neural network.

Mathematically, for inputs \(\mathbf{x} = [x_1, x_2, ..., x_n]\), weights \(\mathbf{w} = [w_1, w_2, ..., w_n]\), and bias \(b\):

\
y =
\begin{cases}
1 & \text{if } \sum_{i=1}^n w_i x_i + b > 0 \\
0 & \text{otherwise}
\end{cases}
\
The perceptron learns the weights and bias by minimizing classification errors on the training data using the **Perceptron Learning Algorithm**.

Simple Implementation of Perceptron for Binary Classification
"""

import numpy as np

class Perceptron:
    def __init__(self, input_size, lr=0.1, epochs=10):
        self.weights = np.zeros(input_size)
        self.bias = 0
        self.lr = lr
        self.epochs = epochs

    def activation(self, x):
        return 1 if x > 0 else 0
        # This is threshold activation function

    def predict(self, x):
        linear_output = np.dot(x, self.weights) + self.bias
        return self.activation(linear_output)

    def fit(self, X, y):
        for _ in range(self.epochs):
            for xi, target in zip(X, y):
                prediction = self.predict(xi)
                error = target - prediction
                # Update weights and bias
                self.weights += self.lr * error * xi
                self.bias += self.lr * error

# Generate simple training data
# Points: (x, y), Label: 1 if y > x else 0
X = np.array([[0, 1], [1, 0], [2, 1], [1, 2], [3, 4], [4, 3]])
y = np.array([1, 0, 0, 1, 1, 0])

print("Training Data:")
for i in range(len(X)):
    print(f"Point {X[i]}: Label {y[i]}")

print("-----------------------------------------")
perceptron = Perceptron(input_size=2, lr=0.1, epochs=20)
perceptron.fit(X, y)

# Test predictions
test_points = np.array([[1, 1], [2, 3], [3, 2]])
for point in test_points:
    print(f"Point {point} classified as: {perceptron.predict(point)}")

# Task: here you have to do it for ceiling and flooring the data, i.e if the input(x) is greater than 0.5 then y is 1, and 0 otherwise.
X = np.array([[0.3],[0.7],[0.6],[0.3],[0.45],[0.89]])
y = np.array([0, 1, 1, 0, 0, 1])

perceptron = Perceptron(input_size=1, lr=0.1, epochs=20)
perceptron.fit(X, y)

# Test predictions
test_points = np.array([[0.41], [0.65], [0.32]])
for point in test_points:
    print(f"Point {point} classified as: {perceptron.predict(point)}")

mmmm

"""## ANN
Artificial Neural Networks (ANN) are computing systems vaguely inspired by the biological neural networks that constitute animal brains.

ANN implementation on MNIST dataset.
"""

import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms
from torch.utils.data import DataLoader
import matplotlib.pyplot as plt

import matplotlib.pyplot as plt
# Prepare Data
transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.1307,), (0.3081,))  # Normalize MNIST data
])

train_dataset = datasets.MNIST(root='./data', train=True, transform=transform, download=True)
test_dataset = datasets.MNIST(root='./data', train=False, transform=transform, download=True)

# if you want to work in fashion dataset

# Load FashionMNIST dataset
# train_dataset = datasets.FashionMNIST(root='./data', train=True, transform=transform, download=True)
# test_dataset = datasets.FashionMNIST(root='./data', train=False, transform=transform, download=True)


train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=1000, shuffle=False)

# Show a few images
fig, axes = plt.subplots(1, 5, figsize=(10, 2))
for i in range(5):
    image, label = train_dataset[i]
    axes[i].imshow(image.squeeze(), cmap='gray')
    axes[i].set_title(f"Label: {label}")
    axes[i].axis('off')
plt.show()

# Define ANN Model
class ANN(nn.Module):
    def __init__(self):
        super(ANN, self).__init__()
        self.fc1 = nn.Linear(28*28, 256)  # Input layer to hidden layer
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(256, 128)    # Hidden layer
        self.fc3 = nn.Linear(128, 10)     # Output layer for 10 classes

    def forward(self, x):
        x = x.view(-1, 28*28)  # Flatten input images
        x = self.relu(self.fc1(x))
        x = self.relu(self.fc2(x))
        x = self.fc3(x)
        return x

# Instantiate model, define loss and optimizer
model = ANN()
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Training loop
def train(model, device, train_loader, optimizer, criterion, epochs=5):
    model.to(device)
    model.train()
    for epoch in range(epochs):
        total_loss = 0
        for data, target in train_loader:
            data, target = data.to(device), target.to(device)
            optimizer.zero_grad()
            output = model(data)
            loss = criterion(output, target)
            loss.backward()
            optimizer.step()
            total_loss += loss.item()
        print(f"Epoch {epoch+1}/{epochs}, Loss: {total_loss/len(train_loader):.4f}")

# Testing loop
def test(model, device, test_loader):
    model.to(device)
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for data, target in test_loader:
            data, target = data.to(device), target.to(device)
            output = model(data)
            pred = output.argmax(dim=1)
            correct += (pred == target).sum().item()
            total += target.size(0)
    print(f"Test Accuracy: {100 * correct / total:.2f}%")

# Run training and testing
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
train(model, device, train_loader, optimizer, criterion, epochs=5)
test(model, device, test_loader)

"""## Inferencing...."""



"""## Convolutional Neural Networks (CNNs)

Convolutional Neural Networks (CNNs) are specialized neural networks primarily used for processing grid-like data such as images. They use convolutional layers to automatically and adaptively learn spatial hierarchies of features through filters/kernels.  

**Convolutional Layer**: Applies a set of learnable filters to the input. Each filter convolves across the input image producing a feature map that activates when a specific feature (edge, texture, pattern) is detected.

**Feature Extraction**: Early convolutional layers capture low-level features (edges, corners), while deeper layers capture higher-level features (shapes, objects).

**Pooling Layers (often used)**: Downsample feature maps, reducing dimensionality and computation.

#### Simple CNN - MNIST Image Data Classification
"""

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms

# Load MNIST dataset
transform = transforms.Compose([transforms.ToTensor()])
train_set = torchvision.datasets.MNIST(root='./data', train=True, download=True, transform=transform)
test_set = torchvision.datasets.MNIST(root='./data', train=False, download=True, transform=transform)

train_loader = torch.utils.data.DataLoader(train_set, batch_size=64, shuffle=True)
test_loader = torch.utils.data.DataLoader(test_set, batch_size=64, shuffle=False)

# for each in test_loader:
#   print(each)

import torch.nn as nn

class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        self.cnn = nn.Sequential(
            # First convolutional block
            nn.Conv2d(1, 16, 3),    # Input: (1, 28, 28) -> Output: (16, 26, 26)
            nn.ReLU(),
            nn.MaxPool2d(2),        # Output: (16, 13, 13)

            # Second convolutional block
            nn.Conv2d(16, 32, 3),   # Output: (32, 11, 11)
            nn.ReLU(),
            nn.MaxPool2d(2),        # Output: (32, 5, 5)

            # Third convolutional block (added)
            nn.Conv2d(32, 64, 3),   # Output: (64, 3, 3)
            nn.ReLU(),
            nn.MaxPool2d(2)         # Output: (64, 1, 1)
        )

        # Fully connected layers
        self.fc = nn.Sequential(
            nn.Linear(64 * 1 * 1, 128),  # Adjusted input size and added hidden layer
            nn.ReLU(),
            nn.Linear(128, 10)           # Output layer for 10 classes
        )

    def forward(self, x):
        x = self.cnn(x)
        x = x.view(-1, 64 * 1 * 1)  # Flatten the output from the CNN layers
        return self.fc(x)

model = SimpleCNN()

# Loss and Optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Training
for epoch in range(5):  # 5 epochs
    for images, labels in train_loader:
        outputs = model(images)
        loss = criterion(outputs, labels)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

    print(f"Epoch [{epoch+1}/5], Loss: {loss.item():.4f}")

correct = 0
total = 0
with torch.no_grad():
    for images, labels in test_loader:
        outputs = model(images)
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

print(f"Test Accuracy: {100 * correct / total:.2f}%")

import matplotlib.pyplot as plt

image, label = test_set[4]
print(f"True Label: {label}")

# Show the image
plt.imshow(image.squeeze(), cmap='gray')
plt.title("Input Image")
plt.show()

image_tensor = image.unsqueeze(0)  # shape: (1, 1, 28, 28)

model.eval()  # set to evaluation mode
with torch.no_grad():
    output = model(image_tensor)
    predicted_class = torch.argmax(output, dim=1).item()

print(f"Predicted Label: {predicted_class}")

from PIL import Image
import torchvision.transforms as transforms
import torch

# Load Image
img = Image.open('/content/your_image.png').convert('L')  # convert to grayscale

# Define the preprocessing
transform = transforms.Compose([
    transforms.Resize((28, 28)),       # Resize to 28x28
    transforms.ToTensor(),             # Convert to tensor
    transforms.Normalize((0.5,), (0.5,))  # Optional: normalize like MNIST
])

# Apply transform
img_tensor = transform(img)  # shape: (1, 28, 28)
img_tensor = img_tensor.unsqueeze(0)  # shape: (1, 1, 28, 28)

# Visualize (optional)
import matplotlib.pyplot as plt
plt.imshow(img_tensor.squeeze(), cmap='gray')
plt.title("Preprocessed Input Image")
plt.show()

model.eval()
with torch.no_grad():
    output = model(img_tensor)
    predicted_class = torch.argmax(output, dim=1).item()

print(f"Predicted Label: {predicted_class}")

"""Limitation of Simple CNN:
- Needs large datasets and high computation.
- Prone to overfitting and limited feature learning.
- Struggles to generalize on unseen data.

### Transfer Learning:

Reuses a pre-trained model for a new but related task.

Saves training time, requires less data, improves performance.

Transfer Learning Architecture:
- **VGGNet (VGG16, VGG19)** â€“ Deep but simple architecture with 16â€“19 layers; good for feature extraction.
- **ResNet (ResNet18, ResNet50, ResNet101, ResNet152)** â€“ Uses residual connections to train very deep networks effectively.
- **MobileNet (MobileNetV2, MobileNetV3)** â€“ Lightweight architecture optimized for mobile and edge devices.
- **EfficientNet (B0â€“B7)** â€“ Balances depth, width, and resolution for high accuracy with fewer parameters.
, Etc

---

## RNN

RNNs are neural networks designed to handle sequential data by maintaining a hidden state that captures information from previous time steps.  
Time series prediction, language modeling, speech recognition, and text generation.

![Untitled.png](data:image/png;base64,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)

Intuition..................

[Slide](https://docs.google.com/presentation/d/1olX4Hyd-wQUwKsh2L7ObT-VYpyjoHTJI-18315_eDek/edit?usp=sharing)

Implementation.....

[Notebook](https://colab.research.google.com/drive/1ePZZbx1mc7qjaDKDpnVRRodMX08gHZVl?usp=sharing)

## LSTMs and GRUs: solving vanishing gradients

*Both Allow gradients to flow over many time steps, solving the vanishing gradient problem in standard RNNs.*   


Uses cell state and gates (input, forget, output) to remember long-term dependencies, preventing vanishing gradients.

GRU: Simplified version with update and reset gates; efficient and effective for long sequences.

![Untitled.png](data:image/png;base64,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)![Untitled.jpg](data:image/jpeg;base64,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)

Intuition............ [Slide](https://docs.google.com/presentation/d/1H4LvHVd7FMRMrUEuoVKR0Cc5UTmsQXkxUsUkQVv5Nts/edit?usp=sharing)
"""

